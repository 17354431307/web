#  第一周作业_完善路由树

## 作业

在我们的课堂里面，我们已经学完了如何构造一棵路由树，同时我们已经支持了静态匹配，通配符匹配和路径参数。

### 必做

现在要你在这个基础上，加强这棵路由树的功能：

+ 通配符匹配：现在我们的通配符匹配只能匹配一段，现在要你修改为，如果通配符出现在路由的未尾，例如 `/a/b/*`，那么它能够匹配到后面多段路由，例如 `/a/b/c/d/e/f`，而目前我们只支持 `/a/b/c`。
+ 正则匹配：你需要额外支持一种正则匹配模式，即用户在注册路由的时候使用了正则表达式。正则表达式的语法设计以及优先级在下面文档里面有描述，你需要仔细阅读这一份文档。

### 选做

在此基础上，你需要提交一份对路由树的基准测试结果。基准测试要求测试不同的情况：

+ 静态匹配
+ 通配符匹配
+ 路径参数
+ 正则匹配

同时利用 `benchmark` 生成的 `profile` 文件，分析路由树的瓶颈。这里不需要分析注册路由的过程，只需要分析查找路由的过程。因为注册路由是在应用启动之前完成的，所以快慢并不重要。



基准测试不需要启动web服务器，单纯测试路由部分就可以。



预估时间：3-4小时。选做部分1小时左右。



注：以下是一棵完整的路由树的设计文档，提到的所有中间件，你们可以在资料汇总文档里面找到对应官网、文档和例子的连接。



## 名词解释

| 路由   | 是指用户注册的规则，用于描述如何将HTTP请求转发到用户的业务代码里面。 |
| ------ | ------------------------------------------------------------ |
| 通配符 | 指符号 `*`                                                   |



## 需求分析

路由树作为 Web 框架的核心，支持到什么样的路由，直接决定了用户是否会选择我们的 Web 框架。

同时，路由树的性能也对 Web 框架影响巨大。所以对路由树一定要做性能分析。并且尝试做优化。

### 场景分析

#### 匹配方式

##### 静态匹配

静态匹配则是最严格的匹配，用户注册的路由和请求的路径必须一一对应。例如，用户输入 `/a/b/c` 路由规则，那么这一条规则只能严格匹配到 `/a/b/c`。

在静态匹配里面，用户可能希望能够忽略大小写，例如 `/a/b/c` 能够匹配到 `/A/b/c`。

但是在我们当下的环境下，忽略大小写已经一个比较少见的需求了，所以我们不打算支持。正常来说，前端发请求到后端，都是固定写好了路径了，不太可能出现一个请求是 `/a/b/c`，一个请求是 `/A/b/c` 的情况。

##### 通配符匹配

通配符匹配是指使用符号 `*` 的匹配方式。符号 `*` 在路由匹配里面是指匹配任意值。例如 `/a/b/*` 可以匹配 `/a/b/c` 也可以匹配 `/a/b/ccccc`。

通配符可以出现在末尾也可以出现在中间。例如在中间 `/a/*/c` 这种路由，可以匹配 `/a/b/c` 也可以匹配 `/a/dddd/c`。

另外一个额外的问题是，通配符可不可以匹配多段？即如果用户输入的是 `/a/*/c` 能不能匹配 `/a/b1/b2/c` 这个路径，又或者 `/a/b/*` 能不能匹配到 `/a/b/c1/c2`。

在这种情况下，我们认为通配符匹配在中间的时候，只能匹配一段，但是在末尾的时候，则能匹配后续所有的路径。即 `/a/*/c` 不能够匹配 `/a/b/c` 但是 `/a/b/*` 能够匹配 `/a/b/c1/c2`.

这种决策是认为，开发者在设计路由的时候，中间有几段，他是能够确定下来的；但是末尾，开发者可能会希望能够匹配到后面任意的路径。

##### 路径参数

路径参数则是指当用户注册路由为 `/user/:id` 的时候，如果请求路径是 `/user/123`，那么这个时候路径参数就是	`(id, 123)`。

路径参数能够在任意位置，而且只能匹配一段。

如果用户重复声明路径参数，例如 `/user/:id/xx/:id`，在这种情况下，既可以在注册路由的时候返回错误，也可以选择使用前面 `id` 的值，或者后面 `id` 的值。

##### 正则匹配

正则匹配通用性更强一点，确切说，前面讨论的通配符匹配，路径参数都可以看做是正则匹配的一种特殊形态。

例如开发者注册一个正则匹配路由 `/user/:id([0-9]+$)`，那么在这种情况下，用户输入 `/user/123` 能够匹配上我们的路由，而 `/user/xiaoming` 则无法匹配。

正则匹配存在一种复合场景，即开发者可能注册两个正则路由，例如 `/user/:id([0-9]+$)`，同时又注册了 `/user/:username(.+)`。这种时候，`/user/123` 将匹配前者，而 `/user/xiaoming` 将匹配后者。

但是在这里，我们将不会支持这种用法。开发者不应该设计这种路由。

#### 路由优先级

在这四种类型的正则路由里面，按照优先级依次是：`静态匹配 > 正则匹配 > 路径参数 > 通配符匹配`。

这种优先级基本符合**最左最精准原则**。需要额外说明的一点，正则匹配的优先级比路径参数高，是因为路径参数可以看做是正则匹配的一种特殊形态，即 `:id(.+)`。所以其它正则表达式，只会比路径参数更加具体，更加精准。

#### 路由回溯

在支持多种路由形态的时候，会出现这么一种问题：如果开发者注册的路由是 `/user/:id/123` 和 `/user/*/xiaoming`。那么当请求路径是 `/user/abc/xiao ming` 的时候该命中哪个路由？

按照我们的优先级原则，在匹配到 `/abc` 这一段的时候，路径参数 `:id` 比通配符的优先级更高，所以我们会优先选择路径参数。但是路径参数之后是 `123` 的静态匹配，这个时候我们的输入是 `xiaoming`，那么显然不会命中。

如果我们回溯一下，发现在 `/abc` 这一段的时候，我们就不能选择 `:id`，而是要选择通配符，后面则能够完美契合。

这就是路由是否回溯的问题。在这里我们选择不支持回溯，因为我们也不希望开发者设计这种路由。如果用户输入了这种路由，那么我们可以返回错误，或者永远忽略掉通配符那条路由。

### 功能需求

支持静态路由、正则路由、路径参数和通配符路由。优先级也是按照这个顺序。同时我们的路由不需要支持回溯。

此外还需要提供：

+ 路由打印功能：用户可以打印所有注册的路由
+ 路由测试功能：用户可以在不启动服务器的时候，测试某个路径是否符合某个路由

### 非功能需求

+ 性能：查找路由的性能必须要很好，并且提供基准测试数据
+ 扩展性：路由树不需要支持开发者自定义路由匹配逻辑
+ 安全性：检测开发者注册的路由，如果不符合条件，或者存在冲突，则返回错误
+ 文档：提供详细的文或者排查路由错误



## 行业方案

### Gin

Gin 支持的路由很多。首先 Gin 支持了标准的 HTTP 方法，而路由形态它支持：

+ 静态匹配
+ 路径参数，其语法形式也是 `:key`
+ 通配符：Gin 的通配符是允许指定部分路径的，例如 `/*action`，那么 `/abcaction` 可以命中

同样地，用户也可以从 Gin 的路由中将路径参数取出来。

### Beego Web

Beego 和 Gin 比起来，还额外支持了正则路由匹配，它的语法形式多种多样：

+ `/user/:id([0-9]+)`
+ `id:int` 这种可以看做是正则表达式的语法糖，Beego 内置了 `int` 的正则表达式，类似地还内置了 `string` 的表达式

Beego 路由还提供了额外的大小写是否敏感的控制选项。

除了这种语法形式以外，例如自动路由：

```go
beego.AutoRouter(&controllers.UserController{})
```

这种其实就是 Beego 内部自己解析 UserController 的信息，将公开方法按照一定的规律转化为对应的路由，目前来说就是按照方法名字来匹配。

另外还有一种注解路由：

```go
//@router /user/list/:id([0-9]+) [get]
func (u *UserController) List() {
    u.Ctx.WriteString("UserController@List func\n")
    id:=u.Ctx.Input.Param(":id")
    u.Ctx.WriteString(id)
}

```

相比之下，Beego Web 的路由功能是最强的。但是 Beego Web 的各种路由以及语法糖的代码混合在一起，很难搞清楚。

### httprouter

httprouter 是一个非常早期的路由树开源框架，后面很多Web框架的路由树实现都深受其影响，例如 Gin。

httprouter 支持的路由种类也非常丰富：

+ 静态匹配
+ 路径参数
+ 通配符匹配：它的通配符和 Gin 效果一样（应该说，Gin 的和它一样）

### Echo

类似地，Echo也支持：

+ 静态匹配
+ 路径参数
+ 通配符匹配

### Iris

Iris 也没有什么特别的地方，它也同样支持静态匹配，路径参数和通配符匹配三种。

### 总结

需要注意的是，这些框架都普遍提供了一种分组功能，或者 `namespace` 功能。本质上分组功能并不属于核心功能（虽然有些框架在核心实现里面嵌入了该功能，但这是一种侵入式地做法，并不值得提倡），而仅仅是一个类似"语法糖"的东西。



## 设计

基本上路由树都是利用前缀树来实现的。例如：

![image-20230820184928187](.\assets\image-20230820184928187.png)

这种路由树的核心是构造最长公共子串。例如 `/v1` 和 `/V2` 最长公共子串就是 `v`，因此 `v` 成了一个公共祖先节点。

并且可以观察到，它们并不是按照路径分隔符 `/` 来进行分割的，而是直接利用 `/` 分割完之后，还要查找公共子串。

这种实现方式会导致它们的代码非常复杂，大部分代码都是在处理最长公共子串，以及调整节点。

我们将采取另外一种简化的操作，即我们直接按照 `/` 分割，并且不再查找最长公共子串。同样的路由，我们最终生成的树是：

![image-20230820185148373](.\assets\image-20230820185148373.png)

注意这两棵路由树，上面的更深，而下面的更宽。这也就是两种设计的取舍。

实际上，从性能的角度来说，两者相差不多。但是无疑后者的代码要简化很多，因为没有最长公共子串的概念。但是在路由树非常庞大的情况，例如有几万条路由的时候，那么前者性能会更加好。只是大多数情况下，一个系统支持的路由数量，超过一干就已经很难维护了。

鉴于此，我们采用这种简化的实现。

### 详细设计

#### 路由树组织

我们采用的是一个 HTTP 方法一棵树。即 GET 方法有一棵树，POST 方法有一棵树......这种表达方式最大的好处就是我们不需要在每一个节点里面都处理 HTTP 方法，而只需要在收到请求的时候找到该请求 HTTP 方法对应的树就可以，所以总体上来说，一个Web模块的所有路由，实质上构成了森林。

![Snipaste_2023-08-20_20-45-19 (1)](.\assets\Snipaste_2023-08-20_20-45-19 (1).png)

####  树结构表示

很显然，路由树是一棵多叉树。在多叉树里面，常见的表达是兄弟儿子表达法，形如：

```go
type Node struct {
    brother *Node
    children []*Node
}
```

一个节点维持了对兄弟节点的引用，同时还维持住了所有的子节点（也可以只维护一个子节点，通过子节点的bro把所有的节点串联起来）。

在我们的路由树里面，我们可以进一步简化这种表达方式：

```go
type node struct {
    // children 子节点
    // 子节点的 path => node
    children map[string] *node
    // handler 命中路由之后执行的逻辑
    handler Handler
    // 通配符 * 表达的节点，任意匹配
    starChild *node
    // 参数路径
    paramChild *node
    // 正则匹配
    regChild *node
}
```

注意到，我们用了一个 `map[string]*node` 用于组织静态匹配，而剩下的通配符、路径参数和正则路由都只是一个单一的 `*node`。

那么显然一棵路由树其实就可以用根节点 `*node` 来表达，所以整个 router 就可以表示成：

```go
type router struct {
    // trees 是按照 HTTP 方法来组织的
    trees map[string] *node
}
```

#### 注册路由

注册路由首先根据 `/` 进行切割分成多段，而后就是查找树，然后找不到匹配节点就创建一个新的子节点的过程。在创建的时候要注意鉴别，应该创建什么子节点。具体步骤是：

+ 如果路径是`*`，那么判断当前节点的通配符子节点 `(star Child)` 是否为nil，如果为 `nil`，则创建一个。而后沿着 `starChild` 继续查找；
+ 如果路径是 `:key(xxxx)` 的形式，那么说明是正则匹配节点，判断 `regChild` 是否为 `nil`，如果为 `nil`，那么创建一个新的 `regChild` 节点。而后沿着 `regChild` 继续查找；
+ 如果路径是 `:key` 的形式，那么说明是路径参数节点，那么判断 `pathChild` 是否为 `nil`，如果为 `nil`，那么创建一个新的 `pathChild` 节点。而后沿着 `pathChild` 继续查找；
+ 重复以上步骤，直到路由分割出来的所有段都被处理完毕；

注册路由的时候需要检测异常情况：

+ 路由必须以 `/` 为前导
+ 路由不能以 `/` 为结束
+ 路由不能存在连续两个 `//`
+ 不能重复注册相同路由
+ 同一个位置只能注册路径参数，通配符路由和正则路由中的一个。也就是三者是互斥的；
+ 同一个位置的路径参数、通配符路由和正则路由都不允许覆盖，例如如果现在已经有了 `/user/:id` 那么再次尝试注册 `/user/:name` 会报错，或者注册 `/user/*` 也会报错。但是再次注册 `/user/:id` 则是合法的；

实际上，因为我们这里将路径参数、通配符路由和正则路由设计为互斥的，所以优先级的意义已经不大了。

#### 查找路由

查找路由类似于注册路由的过程，也是要把请求路径按照 `/` 分割成多段。但是要注意处理路由的优先级：

+ 先从 `children` 里面找，找到了就进行下一段查找；
+ 否则如果注册了正则路由，则用正则表达式进行匹配，如果匹配上了，就进行下一段查找;
+ 否则如果注册了路径参数，则将这一段路径作为参数的值，存入到匹配信息里面，同时进行下一段查找
+ 否则，如果注册了通配符路由，则进行下一段查找。如果通配符节点并没有任何子节点，那么就认为该请求最终匹配上了这个通配符路由；
+ 重复以上步骤，匹配上了任何一个路由，返回匹配信息和该路由；

在没有找到任何匹配路由的时候，路由树本身并不负责返回 `404` 之类的响应。调用者需要根据最终匹配效果，来决定是否返回 `404`。

匹配信息 `(matchlnfo)` 被设计为:

```go
type matchInfo struct {
    n *node
    pathParams mapp[string]string
}
```

其中路径参数和正则匹配到的值都存放在 `PathParams` 里面。



## 例子

### 注册路由

| 已有路由    | 新注册路由                                                   |
| ----------- | ------------------------------------------------------------ |
| `/user/:id` | `/user/:name`：已有路由返回错误<br />`/user/xiaoming`：允许<br />`/user/:name(.*)`：返回错误<br />`/user/:id`: 允许 |

### 路由匹配

| 已有路由       | 请求路径                                                     |
| -------------- | ------------------------------------------------------------ |
| `/user/:id`    | `/user/123：命中`<br />`/user/xiaoming`：命中。注意在路径参数路由里面，我们无法判断 `xiaoming` 是一个不合法的 `id`<br /> |
| `/user/*/home` | `/user/123/home`: 命中<br />`/user/123/345/home`：未命中     |
| `/user/*`      | `/user/123`：命中<br />`/user/456/home/ab`: 命中             |



## 测试

### 单元测试

在注册路由的时候，单元测试需要覆盖所有的异常检查：

+ 路由必须以 `/` 为前导
+ 路由不能以 `/` 为结束
+ 路由不能存在连续两个 `//`
+ 不能重复注册相同路由
+ 同一个位置只能注册路径参数，通配符路由和正则路由中的一个。也就是三者是互斥的；
+ 同一个位置的路径参数、通配符路由和正则路由都不允许覆盖，例如如果现在已经有了 `/user/:id` 那么再次尝试注册 `/user/:name` 会报错，或者注册 `/user/*` 也会报错。但是再次注册 `/user/:id` 则是合法的；

在路由匹配的时候，单元测试必须：

+ 覆盖静态匹配、正则路由、路径参数路由和通配符路由四种
+ 覆盖通配符位于中间以及位于末尾的不同效果
+ 确保正则路由和路径参数路由解析得到的参数值是正确的
+ 要特别测试请求路径是 `/` 的例子
+ 四种路由都要测试只有一段的例子，例如 `/abc` 测试 `/*`，`/:id`，`/:id(.*)` 和 `/abc` 四种路由

### 基准测试

基准测试只需要覆盖路由匹配的过程。





